<html>
<head>
    <title>The Coherent Multiplex</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <style>
        body {
            background: #181818;
            color: #e0e0e0;
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h2 {
            text-align: center;
            margin-top: 32px;
            font-weight: 400;
            letter-spacing: 2px;
        }
        .canvas {
            margin: 32px 0 32px 0;
            width: 100%;
            min-width: 250px;
            max-width: 400px;
            border-radius: 10px;
            box-shadow: 0 2px 12px #000a;
            background: #222;
            padding: 8px 8px 4px 8px;
            box-sizing: border-box;
            display: inline-block;
            vertical-align: top;
        }
        .container {
            width: 100vw;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        
        /* Chat Interface Styles */
        .chat-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: #e0e0e0;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-toggle:hover {
            background: #555;
            transform: scale(1.1);
        }
        
        /* Custom Network Icon */
        .network-icon {
            position: relative;
            width: 24px;
            height: 24px;
        }
        
        .network-icon::before,
        .network-icon::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            background: currentColor;
        }
        
        /* 6 nodes arranged in a hexagon pattern */
        .network-icon::before {
            width: 3px;
            height: 3px;
            top: 2px;
            left: 10px;
            box-shadow: 
                /* Top center node already positioned */
                8px 4px 0 currentColor,    /* Top right */
                8px 14px 0 currentColor,   /* Bottom right */
                0px 18px 0 currentColor,   /* Bottom center */
                -8px 14px 0 currentColor,  /* Bottom left */
                -8px 4px 0 currentColor;   /* Top left */
        }
        
        .chat-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #2a2a2a;
            border-left: 2px solid #444;
            z-index: 1000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0,0,0,0.3);
        }
        
        .chat-sidebar.open {
            right: 0;
        }
        
        .chat-header {
            background: #333;
            color: #e0e0e0;
            padding: 20px;
            border-bottom: 2px solid #444;
            text-align: center;
            font-weight: 600;
            font-size: 18px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .message.user {
            background: #0084ff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        
        .message.agent {
            background: #131457;
            color: white;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        
        .message.system {
            background: #444;
            color: #ccc;
            align-self: center;
            font-style: italic;
            text-align: center;
            font-size: 12px;
        }
        
        .chat-input-area {
            padding: 20px;
            border-top: 2px solid #444;
            background: #333;
        }
        
        .chat-input-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .chat-input {
            flex: 1;
            background: #222;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 12px 16px;
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            min-height: 20px;
            max-height: 100px;
            font-family: inherit;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #0084ff;
        }
        
        .chat-send-btn {
            background: #0084ff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }
        
        .chat-send-btn:hover:not(:disabled) {
            background: #0066cc;
        }
        
        .chat-send-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: #f1f1f1;
            color: #666;
            padding: 12px 16px;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            max-width: 85%;
        }
        
        .typing-dots {
            display: inline-block;
        }
        
        .typing-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <!-- Chat Interface -->
    <button class="chat-toggle" onclick="toggleChat()" title="AI Agent Chat">
        <div class="network-icon"></div>
    </button>
    
    <div class="chat-sidebar" id="chatSidebar">
        <div class="chat-header">
            ðŸ§  Ask Claude
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                Welcome! I'm your AI agent for the Coherent Multiplex. Ask me about the current signals, coherence patterns, or any technical questions about the system.
            </div>
        </div>
        
        <div class="typing-indicator" id="typingIndicator">
            <span class="typing-dots">Claude is thinking</span>
        </div>
        
        <div class="chat-input-area">
            <div style="display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap;">
                <button onclick="askQuickQuestion('Explain the mathematical architecture from the IEEE paper')" 
                        style="background: #444; color: #ccc; border: none; border-radius: 12px; padding: 6px 12px; font-size: 11px; cursor: pointer;">
                    ðŸ“„ IEEE Paper
                </button>
                <button onclick="askQuickQuestion('What are the key mathematical formulas?')" 
                        style="background: #444; color: #ccc; border: none; border-radius: 12px; padding: 6px 12px; font-size: 11px; cursor: pointer;">
                    ðŸ§® Formulas
                </button>
                <button onclick="askQuickQuestion('Analyze current signal patterns')" 
                        style="background: #444; color: #ccc; border: none; border-radius: 12px; padding: 6px 12px; font-size: 11px; cursor: pointer;">
                    ðŸ“Š Analysis
                </button>
            </div>
            <div class="chat-input-container">
                <textarea 
                    class="chat-input" 
                    id="chatInput" 
                    placeholder="Ask about signals, coherence, or math formulas"
                    rows="1"
                    onkeydown="handleChatKeydown(event)"
                ></textarea>
                <button class="chat-send-btn" id="chatSendBtn" onclick="sendMessage()">
                    âž¤
                </button>
            </div>
        </div>
    </div>

    <h2 style="margin-top:12px; margin-bottom:8px;">Coherent Multiplex</h2>
    <div class="container">
        <div class="canvas" style="position:relative;">
            <div style="width:100%; text-align:center; margin-bottom:2px; position:absolute; top:8px; left:0;">
                <span style="font-size:1.25em; font-weight:600; color:#e0e0e0; letter-spacing:1px;">Time Domain</span>
            </div>
            <div id="chart1" style="margin-top:32px;"></div>
        </div>
        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; margin: 32px 16px; font-size: 14px; color: #e0e0e0;">
            <div style="margin-bottom: 8px; font-weight: bold; margin-top: 55px;">Signals</div>
            <div style="display: flex; flex-direction: column; gap: 9px;">
                <!-- Increased icon and letter size for better visibility -->
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(0, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">A</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(24, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">B</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(49, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">C</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(135, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">D</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(180, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">E</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(225, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">F</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(270, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">G</span></div>
                <div style="font-size: 1.45em; font-weight: 500;"><span style="color: hsl(315, 80%, 60%); font-size: 1.7em; vertical-align: middle;">â– </span> <span style="vertical-align: middle;">H</span></div>
            </div>
        </div>
        <div class="canvas" style="position:relative;">
            <div style="width:100%; text-align:center; margin-bottom:2px; position:absolute; top:8px; left:0;">
                <span style="font-size:1.25em; font-weight:600; color:#e0e0e0; letter-spacing:1px;">Frequency Domain</span>
            </div>
            <div id="chart2" style="margin-top:32px;"></div>
        </div>
    </div>
    <!-- Sigma.js graph and distances panel side by side -->
    <div style="display: flex; justify-content: center; align-items: flex-start; margin-bottom: 32px;">
        <div id="sigma-container" style="width:600px; height:600px; border: 2px solid #444; border-radius: 10px; background: #222;"></div>
        <div id="distances-panel" style="min-width:150px; height:590px; margin-left:18px; background:#222; border-radius:10px; box-shadow:0 2px 12px #000a; padding:8px 8px 8px 8px; color:#e0e0e0; font-size:15px; display:inline-block; vertical-align:top; overflow:hidden;">
            <div style="font-weight:bold; margin-bottom:4px; font-size:20px;">Cosine Similarities</div>
            <div id="distances-list"></div>
        </div>
    </div>
    
    <!-- Wavelet Coherence Panel -->
    <div style="display: flex; justify-content: center; align-items: flex-start; margin-bottom: 32px;">
        <div id="coherence-panel" style="width:800px; height:400px; background:#222; border-radius:10px; box-shadow:0 2px 12px #000a; padding:12px; color:#e0e0e0;">
            <div id="coherence-title" style="font-weight:bold; margin-bottom:8px; font-size:20px; text-align:center;">Wavelet Coherence</div>
            <div id="coherence-plot" style="width:100%; height:350px;"></div>
        </div>
    </div>
    <script>
    const N_SIGNALS = 8;
    const FS = 100; // Sampling frequency - this was missing!
    const labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    // All 8 signals on chart1, all 8 FFTs on chart2
    let traces1 = [];
    let traces2 = [];
    // Colors to match legend: A-red, B-orange, C-yellow, D-green, E-cyan, F-blue, G-purple, H-magenta
    const plotColors = [
        '#ff3333', // A - red
        '#ff9933', // B - orange
        '#ffff33', // C - yellow
        '#33ff33', // D - green
        '#33ffff', // E - cyan
        '#3385ff', // F - blue
        '#9933ff', // G - purple
        '#ff33c6'  // H - magenta
    ];
    for (let i = 0; i < N_SIGNALS; i++) {
        const subplotIndex = i + 1;
        traces1.push({
            y: [],
            mode: 'lines',
            name: labels[i],
            line: {shape: 'spline', color: plotColors[i], width: 1.2},
            xaxis: 'x' + subplotIndex,
            yaxis: 'y' + subplotIndex
        });
        traces2.push({
            y: [],
            mode: 'lines',
            name: labels[i] + ' FFT',
            line: {shape: 'spline', color: plotColors[i], width: 1.2},
            xaxis: 'x' + subplotIndex,
            yaxis: 'y' + subplotIndex
        });
    }
    const layout1 = {
        grid: {rows: 8, columns: 1, pattern: 'independent', xgap: 0.01, ygap: 0},
        height: 600,
        width: 400,
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
        margin: {t: 40, l: 30, r: 30, b: 40},
        showlegend: false,
    };
    const layout2 = JSON.parse(JSON.stringify(layout1));
    layout2.showlegend = false;
    for (let i = 1; i <= 8; i++) {
        layout1['yaxis' + (i === 1 ? '' : i)] = {
            showgrid: false,
            zeroline: false,
            showline: false,
            showticklabels: false,
            ticks: '',
            visible: true,
            bgcolor: 'rgba(0,0,0,0)',
        };
        // Only show time axis on bottom subplot
        if (i === 8) {
            layout1['xaxis' + i] = {
                showgrid: false,
                zeroline: false,
                showline: true,
                showticklabels: true,
                ticks: 'outside',
                tickfont: {color: '#e0e0e0', size: 12},
                title: 'Time (centiseconds)',
                titlefont: {color: '#e0e0e0', size: 14},
                bgcolor: 'rgba(0,0,0,0)',
            };
        } else {
            layout1['xaxis' + (i === 1 ? '' : i)] = {
                showgrid: false,
                zeroline: false,
                showline: false,
                showticklabels: false,
                ticks: '',
                visible: true,
                bgcolor: 'rgba(0,0,0,0)',
            };
        }
        // FFT panel: frequency axis on bottom subplot
        layout2['yaxis' + (i === 1 ? '' : i)] = JSON.parse(JSON.stringify(layout1['yaxis' + (i === 1 ? '' : i)]));
        if (i === 8) {
            layout2['xaxis' + i] = {
                showgrid: false,
                zeroline: false,
                showline: true,
                showticklabels: true,
                ticks: 'outside',
                tickfont: {color: '#e0e0e0', size: 12},
                title: 'Frequency (Hz)',
                titlefont: {color: '#e0e0e0', size: 14},
                bgcolor: 'rgba(0,0,0,0)',
            };
        } else {
            layout2['xaxis' + (i === 1 ? '' : i)] = {
                showgrid: false,
                zeroline: false,
                showline: false,
                showticklabels: false,
                ticks: '',
                visible: true,
                bgcolor: 'rgba(0,0,0,0)',
            };
        }
    }
    Plotly.newPlot('chart1', traces1, layout1);
    Plotly.newPlot('chart2', traces2, layout2);

    const source = new EventSource('/stream');
    source.onmessage = function(event) {

        const data = JSON.parse(event.data);
        
        // Store current signal data for the AI agent
        currentSignalData = data;
        
        // Check shapes
        if (!data.signals || !data.fft || !Array.isArray(data.signals) || !Array.isArray(data.fft)) {
            return;
        }
        if (!data.signals[0] || !data.fft[0]) {
            return;
        }
        // Normalize distances to [0, 1] before sending to other scripts
        let rawDistances = Array.isArray(data.distances) ? data.distances : [];
        let normDistances = [];
        if (rawDistances.length > 0) {
            const arr = rawDistances.filter(v => typeof v === 'number');
            let min = Math.min(...arr);
            let max = Math.max(...arr);
            for (let i = 0; i < rawDistances.length; i++) {
                let val = rawDistances[i];
                if (typeof val === 'number' && max > min) {
                    normDistances.push((val - min) / (max - min));
                } else if (typeof val === 'number') {
                    normDistances.push(0);
                } else {
                    normDistances.push('-');
                }
            }
        }
        window.edgeDistances = normDistances;

        // Display normalized distances in the panel
        const distPanel = document.getElementById('distances-list');
        if (distPanel && Array.isArray(window.edgeDistances)) {
            // Generate edge labels (A-B, A-C, ..., G-H)
            const edgeLabels = [];
            for (let i = 0; i < labels.length; i++) {
                for (let j = i + 1; j < labels.length; j++) {
                    edgeLabels.push(`${labels[i]}-${labels[j]}`);
                }
            }
            // Prepare data for hbar plot (1 - distances)
            const arr = window.edgeDistances.map(v => (typeof v === 'number' ? 1 - v : 0));
            // Remove previous plot if exists
            if (window.edgeBarPlot) {
                Plotly.purge('distances-list');
            }
            // Calculate compact height: 18px per item + some margin
            const itemHeight = 18;
            const plotHeight = edgeLabels.length * itemHeight + 40;
            Plotly.newPlot('distances-list', [{
                type: 'bar',
                x: arr,
                y: edgeLabels,
                orientation: 'h',
                marker: {
                    color: 'rgba(0, 200, 255, 0.3)', // Modern blue-cyan
                    line: {width: 0},
                },
                // No text on bars
            }], {
                margin: {l: 20, r: 10, t: 10, b: 10},
                paper_bgcolor: '#222',
                plot_bgcolor: '#222',
                font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                xaxis: {
                    showticklabels: false,
                    showgrid: false,
                    zeroline: false,
                    title: '',
                    range: [0, 1]
                },
                yaxis: {automargin: true},
                bargap: 0.35, // more gap for rounded effect
                height: plotHeight,
                width: document.getElementById('distances-panel').offsetWidth - 16
            }, {displayModeBar: false});
            window.edgeBarPlot = true;
        }

        const N = data.signals[0].length;
        const Nfft = data.fft[0].length;
        const xvals = Array.from({length: N}, (_, k) => k);
        const freqvals = Array.from({length: Nfft}, (_, k) => k * (FS / (2 * Nfft)));
        let traces1 = [];
        let traces2 = [];
        for (let i = 0; i < N_SIGNALS; i++) {
            const subplotIndex = i + 1;
            traces1.push({
                x: xvals,
                y: data.signals[i],
                mode: 'lines',
                name: labels[i],
                line: {shape: 'spline', color: plotColors[i], width: 1.2},
                xaxis: 'x' + subplotIndex,
                yaxis: 'y' + subplotIndex
            });
            // Plot modulus of FFT
            let fft_y = data.fft[i];
            if (fft_y && Array.isArray(fft_y)) {
                fft_y = fft_y.map(v => typeof v === 'object' && v !== null && 're' in v && 'im' in v ? Math.sqrt(v.re*v.re + v.im*v.im) : Math.abs(v));
            } else {
                fft_y = [];
            }
            traces2.push({
                x: freqvals,
                y: fft_y,
                mode: 'lines',
                name: labels[i] + ' FFT',
                line: {shape: 'spline', color: plotColors[i], width: 1.2},
                xaxis: 'x' + subplotIndex,
                yaxis: 'y' + subplotIndex
            });
        }
        Plotly.react('chart1', traces1, layout1);
        Plotly.react('chart2', traces2, layout2);
        
        // Handle wavelet coherence data
        if (data.wavelet_coherence) {
            const cohData = data.wavelet_coherence;
            const cohTitle = document.getElementById('coherence-title');
            if (cohTitle) {
                // Find color indices for the pair
                const idxA = labels.indexOf(cohData.pair_labels[0]);
                const idxB = labels.indexOf(cohData.pair_labels[1]);
                const colorA = plotColors[idxA] || '#fff';
                const colorB = plotColors[idxB] || '#fff';
                cohTitle.innerHTML = `Wavelet Coherence: <span style='color:${colorA}; font-weight:bold;'>&#9632;</span> ${cohData.pair_labels[0]} - <span style='color:${colorB}; font-weight:bold;'>&#9632;</span> ${cohData.pair_labels[1]}`;
            }
            
            // Plot wavelet coherence as heatmap
            if (cohData.coherence && cohData.freqs) {
                const coherenceMatrix = cohData.coherence;
                const freqs = cohData.freqs;
                const phases = cohData.phases || null;
                
                // Create time axis (assuming coherence matrix has time as second dimension)
                const timeSteps = coherenceMatrix[0] ? coherenceMatrix[0].length : 100;
                const timeAxis = Array.from({length: timeSteps}, (_, i) => (i / FS) * 100);
                
                // Prepare traces - start with heatmap
                const traces = [{
                    z: coherenceMatrix,
                    x: timeAxis,
                    y: freqs, // Use actual frequency values (log-scaled)
                    type: 'heatmap',
                    colorscale: 'Jet', // Changed from Viridis to Turbo
                    hoverongaps: false,
                    colorbar: {
                        title: 'Coherence',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        bgcolor: '#222',
                        bordercolor: '#444',
                        borderwidth: 1
                    },
                    showscale: true
                }];
                
                // Add phase arrows if phase data is available
                if (phases && phases.length > 0) {
                    // Different step sizes for frequency and time (higher vertical density, lower horizontal density)
                    const freqStep = 8;  // Increased vertical density (was 8)
                    const timeStep = 11; // Decreased horizontal density (was 8)
                    const arrowX = [];
                    const arrowY = [];
                    const arrowAngles = [];  // Store actual angles in degrees
                    
                    for (let i = 0; i < freqs.length; i += freqStep) {
                        for (let j = 0; j < timeSteps; j += timeStep) {
                            if (phases[i] && phases[i][j] !== undefined) {
                                const phase = phases[i][j];
                                const coherence = coherenceMatrix[i][j];
                                
                                // Only show arrows where coherence is significant (> 0.5)
                                if (coherence > 0.5) {
                                    arrowX.push(timeAxis[j]);
                                    arrowY.push(freqs[i]);
                                    
                                    // Convert phase from radians to degrees and normalize to 0-360
                                    let angleDeg = (phase * 180 / Math.PI) % 360;
                                    if (angleDeg < 0) angleDeg += 360;
                                    arrowAngles.push(angleDeg);
                                }
                            }
                        }
                    }
                    
                    // Add scatter plot with arrow symbols and proper angles
                    if (arrowX.length > 0) {
                        traces.push({
                            x: arrowX,
                            y: arrowY,
                            mode: 'markers',
                            marker: {
                                symbol: 'arrow',
                                size: 14, // Increased arrow size
                                color: 'white',
                                line: {color: 'black', width: 2},
                                angle: arrowAngles, // Use actual phase angles
                                angleref: 'previous' // Angle relative to previous marker
                            },
                            text: arrowAngles.map(angle => `Phase: ${angle.toFixed(1)}Â°`),
                            hovertemplate: '%{text}<extra></extra>',
                            showlegend: false,
                            name: 'Phase'
                        });
                    }
                }
                
                Plotly.newPlot('coherence-plot', traces, {
                    margin: {l: 60, r: 80, t: 20, b: 60},
                    paper_bgcolor: '#222',
                    plot_bgcolor: '#222',
                    font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                    xaxis: {
                        title: 'Time (centiseconds)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        range: [timeAxis[0], timeAxis[timeAxis.length - 1]], // Fix x-axis range
                        tickformat: '.2f',
                        tick0: 0,
                        dtick: (timeAxis[timeAxis.length - 1] - timeAxis[0]) / 5 // Show about 5 ticks
                    },
                    yaxis: {
                        title: 'Frequency (Hz)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        type: 'log', // Use logarithmic scale to match frequency spacing
                        range: [Math.log10(freqs[0]), Math.log10(freqs[freqs.length - 1])], // Fix y-axis range for log scale
                        tickvals: [1, 2, 5, 10, 20, 50], // Explicit tick positions
                        ticktext: ['1', '2', '5', '10', '20', '50'] // Explicit tick labels
                    },
                    height: 350,
                    width: 776
                }, {displayModeBar: false});
                Plotly.react('coherence-plot', traces, {
                    margin: {l: 60, r: 80, t: 20, b: 60},
                    paper_bgcolor: '#222',
                    plot_bgcolor: '#222',
                    font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                    xaxis: {
                        title: 'Time (centiseconds)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        range: [timeAxis[0], timeAxis[timeAxis.length - 1]], // Fix x-axis range
                        tickformat: '.2f',
                        tick0: 0,
                        dtick: (timeAxis[timeAxis.length - 1] - timeAxis[0]) / 5 // Show about 5 ticks
                    },
                    yaxis: {
                        title: 'Frequency (Hz)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        type: 'log', // Use logarithmic scale to match frequency spacing
                        range: [Math.log10(freqs[0]), Math.log10(freqs[freqs.length - 1])], // Fix y-axis range for log scale
                        tickvals: [1, 2, 5, 10, 20, 50], // Explicit tick positions
                        ticktext: ['1', '2', '5', '10', '20', '50'] // Explicit tick labels
                    },
                    height: 350,
                    width: 776
                }, {displayModeBar: false, transition: {duration: 600, easing: 'cubic-in-out'}});
            }
        }
        
        // Use distances from backend to set edge interest
        if (window.updateEdgeInterest) {
            // Randomize interests for each edge
            const edgeIds = [];
            for (let i = 0; i < labels.length; i++) {
                for (let j = i + 1; j < labels.length; j++) {
                    edgeIds.push(`${labels[i]}-${labels[j]}`);
                }
            }
            let edgeInterests = {};
            for (const edgeId of edgeIds) {
                var mode = Math.random() < 0.5 ? 0 : 1;
                var spread = Math.random() * 0.25;
                edgeInterests[edgeId] = mode === 0 ? spread : 1 - spread;
            }
            function getInterest(edgeId) {
                return edgeInterests[edgeId];
            }
            window.updateEdgeInterest(getInterest);
        }
    };
    </script>
    <script src="/static/graphology.min.js"></script>
    <script src="/static/sigma.min.js"></script>
    <script src="/static/graph.js"></script>
    <script>
    // Patch graph.js to accept a getInterest function
    if (window.updateEdgeInterest && typeof window.updateEdgeInterest === 'function') {
        const origUpdate = window.updateEdgeInterest;
        window.updateEdgeInterest = function(getInterest) {
            if (typeof getInterest !== 'function') {
                // fallback to original random interest
                origUpdate();
                return;
            }
            // Animation duration in ms
            const duration = 400;
            const frameRate = 30;
            const steps = Math.round(duration / (1000 / frameRate));
            let startAttrs = {};
            let endAttrs = {};
            const nodeLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const nodeColors = [
                '#ff0000', '#ffff00', '#00ff00', '#00ffff',
                '#0000ff', '#ff00ff', '#ffa500', '#800080'
            ];
            const N = nodeLabels.length;
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex.split('').map(function (h) { return h + h; }).join('');
                }
                var bigint = parseInt(hex, 16);
                var r = (bigint >> 16) & 255;
                var g = (bigint >> 8) & 255;
                var b = bigint & 255;
                return [r, g, b];
            }
            function rgbToHex(r, g, b) {
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            function interpolateColor(color1, color2) {
                var rgb1 = hexToRgb(color1);
                var rgb2 = hexToRgb(color2);
                var r = Math.round((rgb1[0] + rgb2[0]) / 2);
                var g = Math.round((rgb1[1] + rgb2[1]) / 2);
                var b = Math.round((rgb1[2] + rgb2[2]) / 2);
                return [r, g, b];
            }
            function adjustBrightness(rgb, interest) {
                return rgb.map(function(c) {
                    return Math.round(c * interest + 255 * (1 - interest));
                });
            }
            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    var edgeId = nodeLabels[i] + '-' + nodeLabels[j];
                    // Start values
                    let prevInterest = window.interested && window.interested[edgeId] ? window.interested[edgeId] : 0;
                    let prevRgbMid = interpolateColor(nodeColors[i], nodeColors[j]);
                    let prevRgbBright = adjustBrightness(prevRgbMid, prevInterest);
                    let prevColor = rgbToHex(prevRgbBright[0], prevRgbBright[1], prevRgbBright[2]);
                    let prevWidth = 2 + prevInterest * 8;
                    startAttrs[edgeId] = {interest: prevInterest, color: prevColor, width: prevWidth};
                    // End values
                    var interest = getInterest(edgeId);
                    var rgbMid = interpolateColor(nodeColors[i], nodeColors[j]);
                    var rgbBright = adjustBrightness(rgbMid, interest);
                    var edgeColor = rgbToHex(rgbBright[0], rgbBright[1], rgbBright[2]);
                    var edgeWidth = 2 + interest * 8;
                    endAttrs[edgeId] = {interest, color: edgeColor, width: edgeWidth};
                    window.interested[edgeId] = interest;
                }
            }
            // Animate
            let frame = 0;
            function animate() {
                frame++;
                let t = Math.min(frame / steps, 1);
                for (let i = 0; i < N; i++) {
                    for (let j = i + 1; j < N; j++) {
                        var edgeId = nodeLabels[i] + '-' + nodeLabels[j];
                        var s = startAttrs[edgeId];
                        var e = endAttrs[edgeId];
                        // Interpolate interest
                        var interest = s.interest + (e.interest - s.interest) * t;
                        // Interpolate color
                        var sRgb = hexToRgb(s.color);
                        var eRgb = hexToRgb(e.color);
                        var rgb = [
                            Math.round(sRgb[0] + (eRgb[0] - sRgb[0]) * t),
                            Math.round(sRgb[1] + (eRgb[1] - sRgb[1]) * t),
                            Math.round(sRgb[2] + (eRgb[2] - sRgb[2]) * t)
                        ];
                        var color = rgbToHex(rgb[0], rgb[1], rgb[2]);
                        // Interpolate width
                        var width = s.width + (e.width - s.width) * t;
                        if (window.graph && window.graph.hasEdge(nodeLabels[i], nodeLabels[j])) {
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'color', color);
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'size', width);
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'interest', interest);
                        }
                    }
                }
                if (frame < steps) {
                    setTimeout(animate, 1000 / frameRate);
                }
            }
            animate();
        };
    }
    
    // Chat Interface Functions
    let currentSignalData = null;
    let chatOpen = false;
    
    function toggleChat() {
        const sidebar = document.getElementById('chatSidebar');
        const toggle = document.querySelector('.chat-toggle');
        
        chatOpen = !chatOpen;
        
        if (chatOpen) {
            sidebar.classList.add('open');
            toggle.innerHTML = 'âœ•';
            toggle.title = 'Close Chat';
        } else {
            sidebar.classList.remove('open');
            toggle.innerHTML = '<div class="network-icon"></div>';
            toggle.title = 'AI Agent Chat';
        }
    }
    
    function handleChatKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    }
    
    function askQuickQuestion(question) {
        const input = document.getElementById('chatInput');
        input.value = question;
        sendMessage();
    }
    
    async function sendMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        
        if (!message) return;
        
        // Add user message to chat
        addMessage('user', message);
        input.value = '';
        
        // Show typing indicator
        showTypingIndicator();
        
        // Disable send button
        const sendBtn = document.getElementById('chatSendBtn');
        sendBtn.disabled = true;
        
        try {
            const response = await fetch('/agent', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: message,
                    signal_data: currentSignalData
                })
            });
            
            const result = await response.json();
            
            // Hide typing indicator
            hideTypingIndicator();
            
            // Add agent response
            if (result.status === 'success') {
                addMessage('agent', result.response);
            } else {
                addMessage('system', 'Error: ' + result.response);
            }
            
        } catch (error) {
            hideTypingIndicator();
            addMessage('system', 'Network error: ' + error.message);
        } finally {
            sendBtn.disabled = false;
        }
    }
    
    function addMessage(type, content) {
        const messagesContainer = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        
        if (type === 'agent') {
            // Enhanced formatting for agent responses
            let formattedContent = content;
            
            // Convert numbered lists (1. 2. 3. etc.)
            formattedContent = formattedContent.replace(/^(\d+\.\s)/gm, '<br><strong>$1</strong>');
            
            // Convert bullet points (- * â€¢)
            formattedContent = formattedContent.replace(/^[\s]*[-*â€¢]\s/gm, '<br>â€¢ ');
            
            // Convert sub-bullet points (with indentation)
            formattedContent = formattedContent.replace(/^[\s]{2,}[-*â€¢]\s/gm, '<br>&nbsp;&nbsp;â€¢ ');
            
            // Convert headers (## or #)
            formattedContent = formattedContent.replace(/^#+\s*(.+)$/gm, '<br><strong>$1</strong><br>');
            
            // Handle general newlines
            formattedContent = formattedContent.replace(/\n/g, '<br>');
            
            // Clean up multiple consecutive <br> tags
            formattedContent = formattedContent.replace(/(<br>\s*){3,}/g, '<br><br>');
            
            // Remove leading <br> if present
            formattedContent = formattedContent.replace(/^<br>/, '');
            
            // Use innerHTML for formatted content
            messageDiv.innerHTML = formattedContent;
            messagesContainer.appendChild(messageDiv);
            
            // Re-render MathJax for this element if math content is detected
            if (content.includes('$') || content.includes('\\') || content.includes('Î±') || content.includes('Î²') || content.includes('Ïƒ')) {
                if (window.MathJax) {
                    MathJax.typesetPromise([messageDiv]).catch((err) => console.log('MathJax error:', err));
                }
            }
        } else {
            // Use textContent for user and system messages for safety
            messageDiv.textContent = content;
            messagesContainer.appendChild(messageDiv);
        }
        
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    function showTypingIndicator() {
        const indicator = document.getElementById('typingIndicator');
        const messagesContainer = document.getElementById('chatMessages');
        indicator.style.display = 'block';
        messagesContainer.appendChild(indicator);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    function hideTypingIndicator() {
        const indicator = document.getElementById('typingIndicator');
        indicator.style.display = 'none';
    }
    
    // Auto-resize textarea
    document.getElementById('chatInput').addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });
    
    </script>
</body>
</html>
