<html>
<head>
    <title>The Coherent Multiplex</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            background: #181818;
            color: #e0e0e0;
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h2 {
            text-align: center;
            margin-top: 32px;
            font-weight: 400;
            letter-spacing: 2px;
        }
        .canvas {
            margin: 32px 0 32px 0;
            width: 100%;
            min-width: 250px;
            max-width: 400px;
            border-radius: 10px;
            box-shadow: 0 2px 12px #000a;
            background: #222;
            padding: 8px 8px 4px 8px;
            box-sizing: border-box;
            display: inline-block;
            vertical-align: top;
        }
        .container {
            width: 100vw;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
    </style>
</head>
<body>
    <h2 style="margin-top:12px; margin-bottom:8px;">Coherent Multiplex</h2>
    <div class="container">
        <div class="canvas" style="position:relative;">
            <div style="width:100%; text-align:center; margin-bottom:2px; position:absolute; top:8px; left:0;">
                <span style="font-size:1.25em; font-weight:600; color:#e0e0e0; letter-spacing:1px;">Time Domain</span>
            </div>
            <div id="chart1" style="margin-top:32px;"></div>
        </div>
        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; margin: 32px 16px; font-size: 14px; color: #e0e0e0;">
            <div style="margin-bottom: 8px; font-weight: bold; margin-top: 55px;">Signals</div>
            <div style="display: flex; flex-direction: column; gap: 9px;">
                <!-- Increased icon and letter size for better visibility -->
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(0, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">A</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(24, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">B</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(49, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">C</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(135, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">D</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(180, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">E</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(225, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">F</span></div>
                <div style="margin-bottom: 10px; font-size: 1.45em; font-weight: 500;"><span style="color: hsl(270, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">G</span></div>
                <div style="font-size: 1.45em; font-weight: 500;"><span style="color: hsl(315, 80%, 60%); font-size: 1.7em; vertical-align: middle;">■</span> <span style="vertical-align: middle;">H</span></div>
            </div>
        </div>
        <div class="canvas" style="position:relative;">
            <div style="width:100%; text-align:center; margin-bottom:2px; position:absolute; top:8px; left:0;">
                <span style="font-size:1.25em; font-weight:600; color:#e0e0e0; letter-spacing:1px;">Frequency Domain</span>
            </div>
            <div id="chart2" style="margin-top:32px;"></div>
        </div>
    </div>
    <!-- Sigma.js graph and distances panel side by side -->
    <div style="display: flex; justify-content: center; align-items: flex-start; margin-bottom: 32px;">
        <div id="sigma-container" style="width:600px; height:600px; border: 2px solid #444; border-radius: 10px; background: #222;"></div>
        <div id="distances-panel" style="min-width:150px; height:590px; margin-left:18px; background:#222; border-radius:10px; box-shadow:0 2px 12px #000a; padding:8px 8px 8px 8px; color:#e0e0e0; font-size:15px; display:inline-block; vertical-align:top; overflow:hidden;">
            <div style="font-weight:bold; margin-bottom:4px; font-size:20px;">Cosine Similarities</div>
            <div id="distances-list"></div>
        </div>
    </div>
    
    <!-- Wavelet Coherence Panel -->
    <div style="display: flex; justify-content: center; align-items: flex-start; margin-bottom: 32px;">
        <div id="coherence-panel" style="width:800px; height:400px; background:#222; border-radius:10px; box-shadow:0 2px 12px #000a; padding:12px; color:#e0e0e0;">
            <div id="coherence-title" style="font-weight:bold; margin-bottom:8px; font-size:20px; text-align:center;">Wavelet Coherence</div>
            <div id="coherence-plot" style="width:100%; height:350px;"></div>
        </div>
    </div>
    <script>
    const N_SIGNALS = 8;
    const FS = 100; // Sampling frequency - this was missing!
    const labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
    // All 8 signals on chart1, all 8 FFTs on chart2
    let traces1 = [];
    let traces2 = [];
    // Colors to match legend: A-red, B-orange, C-yellow, D-green, E-cyan, F-blue, G-purple, H-magenta
    const plotColors = [
        '#ff3333', // A - red
        '#ff9933', // B - orange
        '#ffff33', // C - yellow
        '#33ff33', // D - green
        '#33ffff', // E - cyan
        '#3385ff', // F - blue
        '#9933ff', // G - purple
        '#ff33c6'  // H - magenta
    ];
    for (let i = 0; i < N_SIGNALS; i++) {
        const subplotIndex = i + 1;
        traces1.push({
            y: [],
            mode: 'lines',
            name: labels[i],
            line: {shape: 'spline', color: plotColors[i], width: 1.2},
            xaxis: 'x' + subplotIndex,
            yaxis: 'y' + subplotIndex
        });
        traces2.push({
            y: [],
            mode: 'lines',
            name: labels[i] + ' FFT',
            line: {shape: 'spline', color: plotColors[i], width: 1.2},
            xaxis: 'x' + subplotIndex,
            yaxis: 'y' + subplotIndex
        });
    }
    const layout1 = {
        grid: {rows: 8, columns: 1, pattern: 'independent', xgap: 0.01, ygap: 0},
        height: 600,
        width: 400,
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
        margin: {t: 40, l: 30, r: 30, b: 40},
        showlegend: false,
    };
    const layout2 = JSON.parse(JSON.stringify(layout1));
    layout2.showlegend = false;
    for (let i = 1; i <= 8; i++) {
        layout1['yaxis' + (i === 1 ? '' : i)] = {
            showgrid: false,
            zeroline: false,
            showline: false,
            showticklabels: false,
            ticks: '',
            visible: true,
            bgcolor: 'rgba(0,0,0,0)',
        };
        // Only show time axis on bottom subplot
        if (i === 8) {
            layout1['xaxis' + i] = {
                showgrid: false,
                zeroline: false,
                showline: true,
                showticklabels: true,
                ticks: 'outside',
                tickfont: {color: '#e0e0e0', size: 12},
                title: 'Time (centiseconds)',
                titlefont: {color: '#e0e0e0', size: 14},
                bgcolor: 'rgba(0,0,0,0)',
            };
        } else {
            layout1['xaxis' + (i === 1 ? '' : i)] = {
                showgrid: false,
                zeroline: false,
                showline: false,
                showticklabels: false,
                ticks: '',
                visible: true,
                bgcolor: 'rgba(0,0,0,0)',
            };
        }
        // FFT panel: frequency axis on bottom subplot
        layout2['yaxis' + (i === 1 ? '' : i)] = JSON.parse(JSON.stringify(layout1['yaxis' + (i === 1 ? '' : i)]));
        if (i === 8) {
            layout2['xaxis' + i] = {
                showgrid: false,
                zeroline: false,
                showline: true,
                showticklabels: true,
                ticks: 'outside',
                tickfont: {color: '#e0e0e0', size: 12},
                title: 'Frequency (Hz)',
                titlefont: {color: '#e0e0e0', size: 14},
                bgcolor: 'rgba(0,0,0,0)',
            };
        } else {
            layout2['xaxis' + (i === 1 ? '' : i)] = {
                showgrid: false,
                zeroline: false,
                showline: false,
                showticklabels: false,
                ticks: '',
                visible: true,
                bgcolor: 'rgba(0,0,0,0)',
            };
        }
    }
    Plotly.newPlot('chart1', traces1, layout1);
    Plotly.newPlot('chart2', traces2, layout2);

    const source = new EventSource('/stream');
    source.onmessage = function(event) {

        const data = JSON.parse(event.data);
        // Check shapes
        if (!data.signals || !data.fft || !Array.isArray(data.signals) || !Array.isArray(data.fft)) {
            return;
        }
        if (!data.signals[0] || !data.fft[0]) {
            return;
        }
        // Normalize distances to [0, 1] before sending to other scripts
        let rawDistances = Array.isArray(data.distances) ? data.distances : [];
        let normDistances = [];
        if (rawDistances.length > 0) {
            const arr = rawDistances.filter(v => typeof v === 'number');
            let min = Math.min(...arr);
            let max = Math.max(...arr);
            for (let i = 0; i < rawDistances.length; i++) {
                let val = rawDistances[i];
                if (typeof val === 'number' && max > min) {
                    normDistances.push((val - min) / (max - min));
                } else if (typeof val === 'number') {
                    normDistances.push(0);
                } else {
                    normDistances.push('-');
                }
            }
        }
        window.edgeDistances = normDistances;

        // Display normalized distances in the panel
        const distPanel = document.getElementById('distances-list');
        if (distPanel && Array.isArray(window.edgeDistances)) {
            // Generate edge labels (A-B, A-C, ..., G-H)
            const edgeLabels = [];
            for (let i = 0; i < labels.length; i++) {
                for (let j = i + 1; j < labels.length; j++) {
                    edgeLabels.push(`${labels[i]}-${labels[j]}`);
                }
            }
            // Prepare data for hbar plot (1 - distances)
            const arr = window.edgeDistances.map(v => (typeof v === 'number' ? 1 - v : 0));
            // Remove previous plot if exists
            if (window.edgeBarPlot) {
                Plotly.purge('distances-list');
            }
            // Calculate compact height: 18px per item + some margin
            const itemHeight = 18;
            const plotHeight = edgeLabels.length * itemHeight + 40;
            Plotly.newPlot('distances-list', [{
                type: 'bar',
                x: arr,
                y: edgeLabels,
                orientation: 'h',
                marker: {
                    color: 'rgba(0, 200, 255, 0.3)', // Modern blue-cyan
                    line: {width: 0},
                },
                // No text on bars
            }], {
                margin: {l: 20, r: 10, t: 10, b: 10},
                paper_bgcolor: '#222',
                plot_bgcolor: '#222',
                font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                xaxis: {
                    showticklabels: false,
                    showgrid: false,
                    zeroline: false,
                    title: '',
                    range: [0, 1]
                },
                yaxis: {automargin: true},
                bargap: 0.35, // more gap for rounded effect
                height: plotHeight,
                width: document.getElementById('distances-panel').offsetWidth - 16
            }, {displayModeBar: false});
            window.edgeBarPlot = true;
        }

        const N = data.signals[0].length;
        const Nfft = data.fft[0].length;
        const xvals = Array.from({length: N}, (_, k) => k);
        const freqvals = Array.from({length: Nfft}, (_, k) => k * (FS / (2 * Nfft)));
        let traces1 = [];
        let traces2 = [];
        for (let i = 0; i < N_SIGNALS; i++) {
            const subplotIndex = i + 1;
            traces1.push({
                x: xvals,
                y: data.signals[i],
                mode: 'lines',
                name: labels[i],
                line: {shape: 'spline', color: plotColors[i], width: 1.2},
                xaxis: 'x' + subplotIndex,
                yaxis: 'y' + subplotIndex
            });
            // Plot modulus of FFT
            let fft_y = data.fft[i];
            if (fft_y && Array.isArray(fft_y)) {
                fft_y = fft_y.map(v => typeof v === 'object' && v !== null && 're' in v && 'im' in v ? Math.sqrt(v.re*v.re + v.im*v.im) : Math.abs(v));
            } else {
                fft_y = [];
            }
            traces2.push({
                x: freqvals,
                y: fft_y,
                mode: 'lines',
                name: labels[i] + ' FFT',
                line: {shape: 'spline', color: plotColors[i], width: 1.2},
                xaxis: 'x' + subplotIndex,
                yaxis: 'y' + subplotIndex
            });
        }
        Plotly.react('chart1', traces1, layout1);
        Plotly.react('chart2', traces2, layout2);
        
        // Handle wavelet coherence data
        if (data.wavelet_coherence) {
            const cohData = data.wavelet_coherence;
            const cohTitle = document.getElementById('coherence-title');
            if (cohTitle) {
                // Find color indices for the pair
                const idxA = labels.indexOf(cohData.pair_labels[0]);
                const idxB = labels.indexOf(cohData.pair_labels[1]);
                const colorA = plotColors[idxA] || '#fff';
                const colorB = plotColors[idxB] || '#fff';
                cohTitle.innerHTML = `Wavelet Coherence: <span style='color:${colorA}; font-weight:bold;'>&#9632;</span> ${cohData.pair_labels[0]} - <span style='color:${colorB}; font-weight:bold;'>&#9632;</span> ${cohData.pair_labels[1]}`;
            }
            
            // Plot wavelet coherence as heatmap
            if (cohData.coherence && cohData.freqs) {
                const coherenceMatrix = cohData.coherence;
                const freqs = cohData.freqs;
                const phases = cohData.phases || null;
                
                // Create time axis (assuming coherence matrix has time as second dimension)
                const timeSteps = coherenceMatrix[0] ? coherenceMatrix[0].length : 100;
                const timeAxis = Array.from({length: timeSteps}, (_, i) => (i / FS) * 100);
                
                // Prepare traces - start with heatmap
                const traces = [{
                    z: coherenceMatrix,
                    x: timeAxis,
                    y: freqs, // Use actual frequency values (log-scaled)
                    type: 'heatmap',
                    colorscale: 'Jet', // Changed from Viridis to Turbo
                    hoverongaps: false,
                    colorbar: {
                        title: 'Coherence',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        bgcolor: '#222',
                        bordercolor: '#444',
                        borderwidth: 1
                    },
                    showscale: true
                }];
                
                // Add phase arrows if phase data is available
                if (phases && phases.length > 0) {
                    // Different step sizes for frequency and time (higher vertical density, lower horizontal density)
                    const freqStep = 8;  // Increased vertical density (was 8)
                    const timeStep = 11; // Decreased horizontal density (was 8)
                    const arrowX = [];
                    const arrowY = [];
                    const arrowAngles = [];  // Store actual angles in degrees
                    
                    for (let i = 0; i < freqs.length; i += freqStep) {
                        for (let j = 0; j < timeSteps; j += timeStep) {
                            if (phases[i] && phases[i][j] !== undefined) {
                                const phase = phases[i][j];
                                const coherence = coherenceMatrix[i][j];
                                
                                // Only show arrows where coherence is significant (> 0.5)
                                if (coherence > 0.5) {
                                    arrowX.push(timeAxis[j]);
                                    arrowY.push(freqs[i]);
                                    
                                    // Convert phase from radians to degrees and normalize to 0-360
                                    let angleDeg = (phase * 180 / Math.PI) % 360;
                                    if (angleDeg < 0) angleDeg += 360;
                                    arrowAngles.push(angleDeg);
                                }
                            }
                        }
                    }
                    
                    // Add scatter plot with arrow symbols and proper angles
                    if (arrowX.length > 0) {
                        traces.push({
                            x: arrowX,
                            y: arrowY,
                            mode: 'markers',
                            marker: {
                                symbol: 'arrow',
                                size: 14, // Increased arrow size
                                color: 'white',
                                line: {color: 'black', width: 2},
                                angle: arrowAngles, // Use actual phase angles
                                angleref: 'previous' // Angle relative to previous marker
                            },
                            text: arrowAngles.map(angle => `Phase: ${angle.toFixed(1)}°`),
                            hovertemplate: '%{text}<extra></extra>',
                            showlegend: false,
                            name: 'Phase'
                        });
                    }
                }
                
                Plotly.newPlot('coherence-plot', traces, {
                    margin: {l: 60, r: 80, t: 20, b: 60},
                    paper_bgcolor: '#222',
                    plot_bgcolor: '#222',
                    font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                    xaxis: {
                        title: 'Time (centiseconds)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        range: [timeAxis[0], timeAxis[timeAxis.length - 1]], // Fix x-axis range
                        tickformat: '.2f',
                        tick0: 0,
                        dtick: (timeAxis[timeAxis.length - 1] - timeAxis[0]) / 5 // Show about 5 ticks
                    },
                    yaxis: {
                        title: 'Frequency (Hz)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        type: 'log', // Use logarithmic scale to match frequency spacing
                        range: [Math.log10(freqs[0]), Math.log10(freqs[freqs.length - 1])], // Fix y-axis range for log scale
                        tickvals: [1, 2, 5, 10, 20, 50], // Explicit tick positions
                        ticktext: ['1', '2', '5', '10', '20', '50'] // Explicit tick labels
                    },
                    height: 350,
                    width: 776
                }, {displayModeBar: false});
                Plotly.react('coherence-plot', traces, {
                    margin: {l: 60, r: 80, t: 20, b: 60},
                    paper_bgcolor: '#222',
                    plot_bgcolor: '#222',
                    font: {color: '#e0e0e0', family: 'Segoe UI,Roboto,Arial,sans-serif'},
                    xaxis: {
                        title: 'Time (centiseconds)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        range: [timeAxis[0], timeAxis[timeAxis.length - 1]], // Fix x-axis range
                        tickformat: '.2f',
                        tick0: 0,
                        dtick: (timeAxis[timeAxis.length - 1] - timeAxis[0]) / 5 // Show about 5 ticks
                    },
                    yaxis: {
                        title: 'Frequency (Hz)',
                        titlefont: {color: '#e0e0e0'},
                        tickfont: {color: '#e0e0e0'},
                        gridcolor: '#444',
                        zerolinecolor: '#666',
                        type: 'log', // Use logarithmic scale to match frequency spacing
                        range: [Math.log10(freqs[0]), Math.log10(freqs[freqs.length - 1])], // Fix y-axis range for log scale
                        tickvals: [1, 2, 5, 10, 20, 50], // Explicit tick positions
                        ticktext: ['1', '2', '5', '10', '20', '50'] // Explicit tick labels
                    },
                    height: 350,
                    width: 776
                }, {displayModeBar: false, transition: {duration: 600, easing: 'cubic-in-out'}});
            }
        }
        
        // Use distances from backend to set edge interest
        if (window.updateEdgeInterest) {
            // Randomize interests for each edge
            const edgeIds = [];
            for (let i = 0; i < labels.length; i++) {
                for (let j = i + 1; j < labels.length; j++) {
                    edgeIds.push(`${labels[i]}-${labels[j]}`);
                }
            }
            let edgeInterests = {};
            for (const edgeId of edgeIds) {
                var mode = Math.random() < 0.5 ? 0 : 1;
                var spread = Math.random() * 0.25;
                edgeInterests[edgeId] = mode === 0 ? spread : 1 - spread;
            }
            function getInterest(edgeId) {
                return edgeInterests[edgeId];
            }
            window.updateEdgeInterest(getInterest);
        }
    };
    </script>
    <script src="/static/graphology.min.js"></script>
    <script src="/static/sigma.min.js"></script>
    <script src="/static/graph.js"></script>
    <script>
    // Patch graph.js to accept a getInterest function
    if (window.updateEdgeInterest && typeof window.updateEdgeInterest === 'function') {
        const origUpdate = window.updateEdgeInterest;
        window.updateEdgeInterest = function(getInterest) {
            if (typeof getInterest !== 'function') {
                // fallback to original random interest
                origUpdate();
                return;
            }
            // Animation duration in ms
            const duration = 400;
            const frameRate = 30;
            const steps = Math.round(duration / (1000 / frameRate));
            let startAttrs = {};
            let endAttrs = {};
            const nodeLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const nodeColors = [
                '#ff0000', '#ffff00', '#00ff00', '#00ffff',
                '#0000ff', '#ff00ff', '#ffa500', '#800080'
            ];
            const N = nodeLabels.length;
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex.split('').map(function (h) { return h + h; }).join('');
                }
                var bigint = parseInt(hex, 16);
                var r = (bigint >> 16) & 255;
                var g = (bigint >> 8) & 255;
                var b = bigint & 255;
                return [r, g, b];
            }
            function rgbToHex(r, g, b) {
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            function interpolateColor(color1, color2) {
                var rgb1 = hexToRgb(color1);
                var rgb2 = hexToRgb(color2);
                var r = Math.round((rgb1[0] + rgb2[0]) / 2);
                var g = Math.round((rgb1[1] + rgb2[1]) / 2);
                var b = Math.round((rgb1[2] + rgb2[2]) / 2);
                return [r, g, b];
            }
            function adjustBrightness(rgb, interest) {
                return rgb.map(function(c) {
                    return Math.round(c * interest + 255 * (1 - interest));
                });
            }
            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    var edgeId = nodeLabels[i] + '-' + nodeLabels[j];
                    // Start values
                    let prevInterest = window.interested && window.interested[edgeId] ? window.interested[edgeId] : 0;
                    let prevRgbMid = interpolateColor(nodeColors[i], nodeColors[j]);
                    let prevRgbBright = adjustBrightness(prevRgbMid, prevInterest);
                    let prevColor = rgbToHex(prevRgbBright[0], prevRgbBright[1], prevRgbBright[2]);
                    let prevWidth = 2 + prevInterest * 8;
                    startAttrs[edgeId] = {interest: prevInterest, color: prevColor, width: prevWidth};
                    // End values
                    var interest = getInterest(edgeId);
                    var rgbMid = interpolateColor(nodeColors[i], nodeColors[j]);
                    var rgbBright = adjustBrightness(rgbMid, interest);
                    var edgeColor = rgbToHex(rgbBright[0], rgbBright[1], rgbBright[2]);
                    var edgeWidth = 2 + interest * 8;
                    endAttrs[edgeId] = {interest, color: edgeColor, width: edgeWidth};
                    window.interested[edgeId] = interest;
                }
            }
            // Animate
            let frame = 0;
            function animate() {
                frame++;
                let t = Math.min(frame / steps, 1);
                for (let i = 0; i < N; i++) {
                    for (let j = i + 1; j < N; j++) {
                        var edgeId = nodeLabels[i] + '-' + nodeLabels[j];
                        var s = startAttrs[edgeId];
                        var e = endAttrs[edgeId];
                        // Interpolate interest
                        var interest = s.interest + (e.interest - s.interest) * t;
                        // Interpolate color
                        var sRgb = hexToRgb(s.color);
                        var eRgb = hexToRgb(e.color);
                        var rgb = [
                            Math.round(sRgb[0] + (eRgb[0] - sRgb[0]) * t),
                            Math.round(sRgb[1] + (eRgb[1] - sRgb[1]) * t),
                            Math.round(sRgb[2] + (eRgb[2] - sRgb[2]) * t)
                        ];
                        var color = rgbToHex(rgb[0], rgb[1], rgb[2]);
                        // Interpolate width
                        var width = s.width + (e.width - s.width) * t;
                        if (window.graph && window.graph.hasEdge(nodeLabels[i], nodeLabels[j])) {
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'color', color);
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'size', width);
                            window.graph.setEdgeAttribute(nodeLabels[i], nodeLabels[j], 'interest', interest);
                        }
                    }
                }
                if (frame < steps) {
                    setTimeout(animate, 1000 / frameRate);
                }
            }
            animate();
        };
    }
    </script>
</body>
</html>
